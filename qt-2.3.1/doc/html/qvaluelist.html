<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Qt Toolkit - QValueList Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }body { background: white; color: black; }
--></style>
</head><body bgcolor="#ffffff">

<table width="100%">
<tr><td><a href="index.html">
<img width="100" height="100" src="qtlogo.png"
alt="Home" border="0"><img width="100"
height="100" src="face.png" alt="Home" border="0">
</a><td valign=top><div align=right><img src="dochead.png" width="472" height="27"><br>
<a href="classes.html"><b>Classes</b></a>
- <a href="annotated.html">Annotated</a>
- <a href="hierarchy.html">Tree</a>
- <a href="functions.html">Functions</a>
- <a href="index.html">Home</a>
- <a href="topicals.html"><b>Structure</b></a>
</div>
</table>

<h1 align=center>QValueList Class Reference</h1><br clear="all">
<p>
The QValueList class is a value based template class that provides doubly linked lists.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qvaluelist-h.html">qvaluelist.h</a>&gt;</code>
<p><a href="qvaluelist-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><div class="fn"><a href="#10900c"><b>QValueList</b></a> () </div>
<li><div class="fn"><a href="#4383a9"><b>QValueList</b></a> ( const QValueList&lt;T&gt; &amp; l ) </div>
<li><div class="fn"><a href="#57f53f"><b>~QValueList</b></a> () </div>
<li><div class="fn">QValueList&lt;T&gt;&amp; <a href="#5a6fff"><b>operator=</b></a> ( const QValueList&lt;T&gt; &amp; l ) </div>
<li><div class="fn">QValueList&lt;T&gt; <a href="#82ef20"><b>operator+</b></a> ( const QValueList&lt;T&gt; &amp; l ) const</div>
<li><div class="fn">QValueList&lt;T&gt;&amp; <a href="#f0af79"><b>operator+=</b></a> ( const QValueList&lt;T&gt; &amp; l ) </div>
<li><div class="fn">bool <a href="#8a8cd4"><b>operator==</b></a> ( const QValueList&lt;T&gt; &amp; l ) const</div>
<li><div class="fn">bool <a href="#dfb071"><b>operator!=</b></a> ( const QValueList&lt;T&gt; &amp; l ) const</div>
<li><div class="fn">Iterator <a href="#7bdcbf"><b>begin</b></a> () </div>
<li><div class="fn">ConstIterator <a href="#e6e054"><b>begin</b></a> () const</div>
<li><div class="fn">Iterator <a href="#33bf3e"><b>end</b></a> () </div>
<li><div class="fn">ConstIterator <a href="#6c232e"><b>end</b></a> () const</div>
<li><div class="fn">Iterator <a href="#c184e3"><b>fromLast</b></a> () </div>
<li><div class="fn">ConstIterator <a href="#77bdf7"><b>fromLast</b></a> () const</div>
<li><div class="fn">bool <a href="#bfa923"><b>isEmpty</b></a> () const</div>
<li><div class="fn">Iterator <a href="#440925"><b>insert</b></a> ( Iterator it, const T &amp; x ) </div>
<li><div class="fn">Iterator <a href="#e5e044"><b>append</b></a> ( const T &amp; x ) </div>
<li><div class="fn">Iterator <a href="#ac9e47"><b>prepend</b></a> ( const T &amp; x ) </div>
<li><div class="fn">Iterator <a href="#69caea"><b>remove</b></a> ( Iterator it ) </div>
<li><div class="fn">void <a href="#9e0039"><b>remove</b></a> ( const T &amp; x ) </div>
<li><div class="fn">T&amp; <a href="#1d2fcd"><b>first</b></a> () </div>
<li><div class="fn">const T&amp; <a href="#96a8c0"><b>first</b></a> () const</div>
<li><div class="fn">T&amp; <a href="#c33269"><b>last</b></a> () </div>
<li><div class="fn">const T&amp; <a href="#ad5c15"><b>last</b></a> () const</div>
<li><div class="fn">T&amp; <a href="#ed67ba"><b>operator[]</b></a> ( uint i ) </div>
<li><div class="fn">const T&amp; <a href="#35f9f9"><b>operator[]</b></a> ( uint i ) const</div>
<li><div class="fn">Iterator <a href="#b4fc8b"><b>at</b></a> ( uint i ) </div>
<li><div class="fn">ConstIterator <a href="#c9d509"><b>at</b></a> ( uint i ) const</div>
<li><div class="fn">Iterator <a href="#6c3b1c"><b>find</b></a> ( const T &amp; x ) </div>
<li><div class="fn">ConstIterator <a href="#d3391b"><b>find</b></a> ( const T &amp; x ) const</div>
<li><div class="fn">Iterator <a href="#292afb"><b>find</b></a> ( Iterator it, const T &amp; x ) </div>
<li><div class="fn">ConstIterator <a href="#976658"><b>find</b></a> ( ConstIterator it, const T &amp; x ) const</div>
<li><div class="fn">int <a href="#bf475d"><b>findIndex</b></a> ( const T &amp; x ) const</div>
<li><div class="fn">uint <a href="#f12791"><b>contains</b></a> ( const T &amp; x ) const</div>
<li><div class="fn">uint <a href="#e20e16"><b>count</b></a> () const</div>
<li><div class="fn">void <a href="#172e6a"><b>clear</b></a> () </div>
<li><div class="fn">QValueList&lt;T&gt;&amp; <a href="#841828"><b>operator+=</b></a> ( const T &amp; x ) </div>
<li><div class="fn">QValueList&lt;T&gt;&amp; <a href="#6b5b29"><b>operator&lt;&lt;</b></a> ( const T &amp; x ) </div>
</ul>
<h2>Protected Members</h2>
<ul>
<li><div class="fn">void <a href="#dec767"><b>detach</b></a> () </div>
</ul>
<h2>Related Functions</h2>
(Note that these are not member functions.)
<ul>
<li>QDataStream&amp; <a href="qvaluelist.html#deaae1"><b>operator&lt;&lt;</b></a> (QDataStream &amp; s, const QValueList&lt;T&gt; &amp; l)
<li>QDataStream&amp; <a href="qvaluelist.html#e66a66"><b>operator&gt;&gt;</b></a> (QDataStream &amp; s, QValueList&lt;T&gt; &amp; l)
</ul>
<hr><h2><a name="details"></a>Detailed Description</h2>
The QValueList class is a value based template class that provides doubly linked lists.
<p>
Define a template instance QValueList&lt;X&gt; to create a list of values which all
have the class X. Please notice that QValueList does not store pointers to the
members of the list. It holds a copy of every member. That is the reason why this
kind of classes are called "value based" while <a href="qlist.html">QList</a> and <a href="qdict.html">QDict</a> are "reference based".
<p>Some classes can not be used within a QValueList,  for example everything
derived from <a href="qobject.html">QObject</a> and thus all classes that implement widgets.
Only values can be used in a QValueList. To qualify as a value, the class
must provide
<ul>
<li>a copy constructor,
<li>an assignment operator and
<li> a default constructor, i.e. a constructor that does not take any arguments.
</ul>
<p>Note that C++ defaults to field-by-field assignment operators and
copy constructors if no explicit version is supplied. In many cases,
this is sufficient.
<p>Example:
<pre>    #include &lt;qvaluelist.h&gt;
    #include &lt;qstring.h&gt;
    #include &lt;stdio.h&gt;

    class Employee
    {
    public:
        Employee(): s(0) {}
        Employee( const QString&amp; name, int salary )
            : n(name), s(salary)
        {}

        <a href="qstring.html">QString</a>     name()   const              { return n; }
        int         salary() const              { return s; }
        void        setSalary( int salary )     { s = salary; }
    private:
        <a href="qstring.html">QString</a>     n;
        int         s;
    };

    void main()
    {
        typedef QValueList&lt;Employee&gt; EmployeeList;
        EmployeeList list;              // list of Employee

        list.append( Employee("Bill", 50000) );
        list.append( Employee("Steve",80000) );
        list.append( Employee("Ron",  60000) );

        Employee joe( "Joe", 50000 );
        list.append( joe );
        joe.setSalary( 4000 );

        EmployeeList::Iterator it;
        for( it = list.begin(); it != list.end(); ++it )
            printf( "%s earns %d\n", (*it).name().latin1(), (*it).salary().latin1() );
    }
</pre>
<p>Program output:
<pre>        Bill earns 50000
        Steve earns 80000
        Ron earns 60000
        Joe earns 50000
</pre>
<p>As you can see, the latest changes to Joes salary did not affect the value
in the list because the list created a copy of Joes entry.
<p>There are three ways of finding items in the list. The first one is by using
the <a href="#b4fc8b">at</a>() function. It returns an iterator. The advantages of
getting an iterator is that you can now move forward or backward from this
position by incrementing/decrementing the iterator. To get the amount of
items in the list call <a href="#e20e16">count</a>(). Valid indices are 0..count().
<p>The second way of accessing a list is with operator[]. That means you can address
it like an array. The return value is a reference to the value stored in the list.
There exist two versions of this operator. The first one is const and returns a
const reference to the value. The second on is non const and returns a non const
reference to the value. It is up to your compiler to choose the correct one.
<p>The third method is to use the functions <a href="#7bdcbf">begin</a>() and <a href="#33bf3e">end</a>().
With a simple for loop as shown in the example you can iterate over the complete list.
It is save to have multiple iterators at the same time. If some member of the list is
removed then only iterators pointing to the removed member become invalid. Inserting in
the list does not invalidate any iterator. For convenience the function <a href="#ad5c15">last</a>() returns
an iterator for the last and <a href="#1d2fcd">first</a>() for the first element in the list.
<p>In addition you can search items in the list with the <a href="#292afb">find</a>() function. It exists in a const
and a non const version. It starts searching from the beginning of the list, but another
flavor of the find() function allows you to specify where searching should start.
If you just want to know wether a certain item is at least once in the list, then you
can use the <a href="#f12791">contains</a>() function.
<p>Since QValueList is value based there is no need to care about deleting elements in the
list. The list holds its own copies and will free them if the corresponding member or
the list itself is deleted. You can force the list to free all of its item with <a href="#172e6a">clear</a>().
<p>QValueList is implicitly shared. That means you can just make copies of the list
in time O(1). If multiple QValueList instances share the same data and one
is doing a modification of the lists data then this modifying instance makes a copy
and modifies its private copy. So it does not affect the other instances.
From a developers point of view you can think that a QValueList and a copy of this
list have nothing to do with each other. Developers may only notice that copying is
very fast. People known to a CPUs MMU architecture will know this pattern as "copy on write".
<p>There exist three functions to insert items in the list. <a href="#e5e044">append</a>()
inserts an item at the end, <a href="#ac9e47">prepend</a>() inserts at the beginning
and <a href="#440925">insert</a>() inserts in front of the position given by an iterator.
<p>Items can be removed from the list in two ways. The first is to pass an iterator to
the <a href="#69caea">remove</a>(). The other possibility is to pass a value to remove() which will
delete all members which match this value.
<p>Lists can be sorted with the algorithms provided by the <a
href="qtl.html">Qt Template Library</a>, for example with
qHeapSort():
<p>Example:
<pre>          <a href="qvaluelist.html">QValueList</a> l;
          l.<a href="#e5e044">append</a>( 5 );
          l.<a href="#e5e044">append</a>( 8 );
          l.<a href="#e5e044">append</a>( 3 );
          l.<a href="#e5e044">append</a>( 4 );
          qHeapSort( l );
</pre>
<p>See also  <a href="qvaluelistiterator.html">QValueListIterator</a>.

<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="10900c"></a>QValueList::QValueList ()</h3>
<p>Constructs an empty list.
<h3 class="fn"><a name="4383a9"></a>QValueList::QValueList ( const QValueList&lt;T&gt; &amp; l )</h3>
<p>Constructs a copy of <em>l.</em>
<p>This operation costs O(1) time since QValueList is implicit shared.
The first instance applying modifications to a shared list will create
a copy which takes in turn O(<a href="n.html">n</a>) time. However returning a QValueList from
a function is very fast.
<h3 class="fn"><a name="57f53f"></a>QValueList::~QValueList ()</h3>
<p>Destroys the list. References to the values in the list and all iterators
of this list become invalidated. Since QValueList is highly tuned for performance
you wont see warnings if you use invalid iterators,
because it is impossible for
an iterator to check wether it is valid or not.
<h3 class="fn">Iterator <a name="e5e044"></a>QValueList::append ( const T &amp; x )</h3>
<p>Inserts the value <em>x</em> at the end of the list.
<p>Returns an iterator pointing at the inserted item.
<p>See also  <a href="#440925">insert</a>() and <a href="#ac9e47">prepend</a>().
<h3 class="fn">ConstIterator <a name="c9d509"></a>QValueList::at ( uint i ) const</h3>
<p>Returns an iterator pointing to the item at position <em>i</em> in the list, or
<a href="#33bf3e">end</a>() if the index is out of range.
<h3 class="fn">Iterator <a name="b4fc8b"></a>QValueList::at ( uint i )</h3>
<p>Returns an iterator pointing to the item at position <em>i</em> in the list, or
<a href="#33bf3e">end</a>() if the index is out of range.
<h3 class="fn">ConstIterator <a name="e6e054"></a>QValueList::begin () const</h3>
<p>Returns an iterator pointing to the first element in the list. This
iterator equals <a href="#33bf3e">end</a>() if the list is empty;
<p>See also  <a href="#1d2fcd">first</a>() and <a href="#33bf3e">end</a>().
<h3 class="fn">Iterator <a name="7bdcbf"></a>QValueList::begin ()</h3>
<p>Returns an iterator pointing to the first element in the list. This
iterator equals <a href="#33bf3e">end</a>() if the list is empty;
<p>See also  <a href="#1d2fcd">first</a>() and <a href="#33bf3e">end</a>().
<h3 class="fn">void <a name="172e6a"></a>QValueList::clear ()</h3>
<p>Removes all items from the list.
<p>See also  <a href="#69caea">remove</a>().
<h3 class="fn">uint <a name="f12791"></a>QValueList::contains ( const T &amp; x ) const</h3>
<p>Counts and returns the number of occurrences of the value <em>x</em> in the list.
<h3 class="fn">uint <a name="e20e16"></a>QValueList::count () const</h3>
<p>Returns the number of items in the list.
<p>See also  <a href="#bfa923">isEmpty</a>().
<h3 class="fn">void <a name="dec767"></a>QValueList::detach () <code>[protected]</code></h3>
<p>If the list does not share its data with another QValueList instance, then nothing
happens, otherwise the function creates a new copy of this data and detaches
from the shared one. This function is called whenever the list is modified.
The implicit sharing mechanism is implemented this way.
<h3 class="fn">ConstIterator <a name="6c232e"></a>QValueList::end () const</h3>
<p>Returns an iterator pointing behind the last element in the list. This
iterator equals <a href="#7bdcbf">begin</a>() if the list is empty.
<p>See also  <a href="#ad5c15">last</a>() and <a href="#7bdcbf">begin</a>().
<h3 class="fn">Iterator <a name="33bf3e"></a>QValueList::end ()</h3>
<p>Returns an iterator pointing behind the last element in the list. This
iterator equals <a href="#7bdcbf">begin</a>() if the list is empty.
<p>See also  <a href="#ad5c15">last</a>() and <a href="#7bdcbf">begin</a>().
<h3 class="fn">ConstIterator <a name="976658"></a>QValueList::find ( ConstIterator it, const T &amp; x ) const</h3>
<p>Finds the first occurrence of <em>x</em> in the list starting at
the position given by <em>it.</em>
<p>Returns <a href="#33bf3e">end</a>() if no item did match.
<h3 class="fn">ConstIterator <a name="d3391b"></a>QValueList::find ( const T &amp; x ) const</h3>
<p>Finds the first occurrence of <em>x</em> in the list.
<p>Returns <a href="#33bf3e">end</a>() if no item did match.
<h3 class="fn">Iterator <a name="292afb"></a>QValueList::find ( Iterator it, const T &amp; x )</h3>
<p>Finds the first occurrence of <em>x</em> in the list starting at
the position given by <em>it.</em>
<p>Returns <a href="#33bf3e">end</a>() if no item did match.
<h3 class="fn">Iterator <a name="6c3b1c"></a>QValueList::find ( const T &amp; x )</h3>
<p>Finds the first occurrence of <em>x</em> in the list.
<p>Returns <a href="#33bf3e">end</a>() if no item did match.
<h3 class="fn">int <a name="bf475d"></a>QValueList::findIndex ( const T &amp; x ) const</h3>
<p>Returns the first index of the value <em>x</em> in the list or -1 if no such value
can be found in the list.
<h3 class="fn">T&amp; <a name="1d2fcd"></a>QValueList::first ()</h3>
<p>Returns a reference to the first item in the list or the item
referenced by <a href="#33bf3e">end</a>()
if no such items exists. Please note that you may not change
the value the end() Iterator is pointing to.
<p>See also  <a href="#7bdcbf">begin</a>() and <a href="#ad5c15">last</a>().
<h3 class="fn">const T&amp; <a name="96a8c0"></a>QValueList::first () const</h3>
<p>Returns a reference to the first item in the list or the item
referenced by <a href="#33bf3e">end</a>() if
no such items exists.
<p>See also  <a href="#7bdcbf">begin</a>() and <a href="#ad5c15">last</a>().
<h3 class="fn">ConstIterator <a name="77bdf7"></a>QValueList::fromLast () const</h3>
<p>Returns an iterator pointing to the last element in the list or
<a href="#33bf3e">end</a>() if no such item exists.
<p>See also  <a href="#ad5c15">last</a>().
<h3 class="fn">Iterator <a name="c184e3"></a>QValueList::fromLast ()</h3>
<p>Returns an iterator pointing to the last element in the list or
<a href="#33bf3e">end</a>() if no such item exists.
<p>See also  <a href="#ad5c15">last</a>().
<h3 class="fn">Iterator <a name="440925"></a>QValueList::insert ( Iterator it, const T &amp; x )</h3>
<p>Inserts the value <em>x</em> in front of the iterator <em>it.</em>
<p>Returns an iterator pointing at the inserted item.
<p>See also  <a href="#e5e044">append</a>() and <a href="#ac9e47">prepend</a>().
<h3 class="fn">bool <a name="bfa923"></a>QValueList::isEmpty () const</h3>
<p>Returns TRUE if the list is empty, i.e. <a href="#e20e16">count</a>() == 0. Returns FALSE
otherwise.
<p>See also  <a href="#e20e16">count</a>().
<h3 class="fn">T&amp; <a name="c33269"></a>QValueList::last ()</h3>
<p>Returns a reference to the last item in the list or the item
referenced by <a href="#33bf3e">end</a>() if no
such item exists. Please note that you may not change
the value the end() Iterator is pointing to.
<p>See also  <a href="#33bf3e">end</a>(), <a href="#1d2fcd">first</a>() and <a href="#77bdf7">fromLast</a>().
<h3 class="fn">const T&amp; <a name="ad5c15"></a>QValueList::last () const</h3>
<p>Returns a reference to the last item in the list or the item
referenced by <a href="#33bf3e">end</a>() if no such item exists.
<p>See also  <a href="#33bf3e">end</a>(), <a href="#1d2fcd">first</a>() and <a href="#77bdf7">fromLast</a>().
<h3 class="fn">bool <a name="dfb071"></a>QValueList::operator!= ( const QValueList&lt;T&gt; &amp; l ) const</h3>
<p>Compares both lists.
<p>Returns TRUE if both list are unequal.
<h3 class="fn">QValueList&lt;T&gt; <a name="82ef20"></a>QValueList::operator+ ( const QValueList&lt;T&gt; &amp; l ) const</h3>
<p>Creates a new list and fills it with the elements of this list. Then the
elements of <em>l</em> are appended.
<p>Returns the new list.
<h3 class="fn">QValueList&lt;T&gt;&amp; <a name="f0af79"></a>QValueList::operator+= ( const QValueList&lt;T&gt; &amp; l )</h3>
<p>Adds <em>list</em> to this list.
<p>Returns a reference to this list.
<h3 class="fn">QValueList&lt;T&gt;&amp; <a name="841828"></a>QValueList::operator+= ( const T &amp; x )</h3>
<p>Adds the value <em>x</em> to the end of the list.
<p>Returns a reference to the list.
<h3 class="fn">QValueList&lt;T&gt;&amp; <a name="6b5b29"></a>QValueList::operator&lt;&lt; ( const T &amp; x )</h3>
<p>Adds the value <em>x</em> to the end of the list.
<p>Returns a reference to the list.
<h3 class="fn">QValueList&lt;T&gt;&amp; <a name="5a6fff"></a>QValueList::operator= ( const QValueList&lt;T&gt; &amp; l )</h3>
<p>Assigns <em>l</em> to this list and returns a reference to this list.
<p>All iterators of the current list become invalidated by this operation.
The cost of such an assignment is O(1) since QValueList is implicitly shared.
<h3 class="fn">bool <a name="8a8cd4"></a>QValueList::operator== ( const QValueList&lt;T&gt; &amp; l ) const</h3>
<p>Compares both lists.
<p>Returns TRUE if both list are equal.
<h3 class="fn">T&amp; <a name="ed67ba"></a>QValueList::operator[] ( uint i )</h3>
<p>Returns a reference to the item with index <em>i</em> in the list.
It is up to you to check wether this item really exists. You can do that easily
with the <a href="#e20e16">count</a>() function. However this operator does not check wether <em>i</em>
is in range and will deliver undefined results if it does not exist.
In contrast to the const operator[] you may manipulate the value returned by this
operator.
<h3 class="fn">const T&amp; <a name="35f9f9"></a>QValueList::operator[] ( uint i ) const</h3>
<p>Returns a const reference to the item with index <em>i</em> in the list.
It is up to you to check wether this item really exists. You can do that easily
with the <a href="#e20e16">count</a>() function. However this operator does not check wether <em>i</em>
is in range and will deliver undefined results if it does not exist.
<h3 class="fn">Iterator <a name="ac9e47"></a>QValueList::prepend ( const T &amp; x )</h3>
<p>Inserts the value <em>x</em> at the beginning of the list.
<p>Returns an iterator pointing at the inserted item.
<p>See also  <a href="#440925">insert</a>() and <a href="#e5e044">append</a>().
<h3 class="fn">Iterator <a name="69caea"></a>QValueList::remove ( Iterator it )</h3>
<p>Removes the item at position <em>it</em> in the list.
<p>Returns an iterator pointing to the item following the
removed on or <a href="#33bf3e">end</a>() if the last item was deleted.
<p>See also  <a href="#172e6a">clear</a>().
<h3 class="fn">void <a name="9e0039"></a>QValueList::remove ( const T &amp; x )</h3>
<p>Removes all items which have the value <em>x.</em>
<p>See also  <a href="#172e6a">clear</a>().
<hr><h2>Related Functions</h2>
<h3><a href="qdatastream.html">QDataStream</a>&amp; <a name="deaae1"></a>operator&lt;&lt; (<a href="qdatastream.html">QDataStream</a> &amp; s, const QValueList&lt;T&gt; &amp; l)</h3>
<p>Writes a list to the stream. The type <em>T</em> stored in the list must implement
the streaming operator, too.

<h3><a href="qdatastream.html">QDataStream</a>&amp; <a name="e66a66"></a>operator&gt;&gt; (<a href="qdatastream.html">QDataStream</a> &amp; s, QValueList&lt;T&gt; &amp; l)</h3>
<p>Reads a list from the stream. The type <em>T</em> stored in the list must implement
the streaming operator, too.

<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses
<a href="http://www.trolltech.com">www.trolltech.com</a>):<br>
<form method=post action="http://www.trolltech.com/search.cgi">
<input type=hidden name="version" value="2.3.1"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-2000
<a href="http://www.trolltech.com">Trolltech</a>, all rights reserved.<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 2000 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 2.3.1</div>
</table></div></address></body></html>
