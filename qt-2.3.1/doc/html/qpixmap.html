<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Qt Toolkit - QPixmap Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }body { background: white; color: black; }
--></style>
</head><body bgcolor="#ffffff">

<table width="100%">
<tr><td><a href="index.html">
<img width="100" height="100" src="qtlogo.png"
alt="Home" border="0"><img width="100"
height="100" src="face.png" alt="Home" border="0">
</a><td valign=top><div align=right><img src="dochead.png" width="472" height="27"><br>
<a href="classes.html"><b>Classes</b></a>
- <a href="annotated.html">Annotated</a>
- <a href="hierarchy.html">Tree</a>
- <a href="functions.html">Functions</a>
- <a href="index.html">Home</a>
- <a href="topicals.html"><b>Structure</b></a>
</div>
</table>

<h1 align=center>QPixmap Class Reference</h1><br clear="all">
<p>
The QPixmap class is an off-screen pixel-based paint device.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qpixmap-h.html">qpixmap.h</a>&gt;</code>
<p>
Inherits <a href="qpaintdevice.html">QPaintDevice</a> and <a href="qt.html">Qt</a>.
<p>Inherited by <a href="qbitmap.html">QBitmap</a> and <a href="qcanvaspixmap.html">QCanvasPixmap</a>.
<p><a href="qpixmap-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><div class="fn">enum <a href="#ColorMode"><b>ColorMode</b></a> { Auto, Color, Mono }</div>
<li><div class="fn">enum <a href="#Optimization"><b>Optimization</b></a> { DefaultOptim, NoOptim, MemoryOptim=NoOptim, NormalOptim, BestOptim }</div>
<li><div class="fn"><a href="#1668f6"><b>QPixmap</b></a> () </div>
<li><div class="fn"><a href="#d62968"><b>QPixmap</b></a> ( int w, int h, int depth = -1, Optimization = DefaultOptim ) </div>
<li><div class="fn"><a href="#08aba0"><b>QPixmap</b></a> ( const QSize &amp;, int depth = -1, Optimization = DefaultOptim ) </div>
<li><div class="fn"><a href="#8141b4"><b>QPixmap</b></a> ( const QString &amp; fileName, const char * format=0, ColorMode mode=Auto ) </div>
<li><div class="fn"><a href="#393682"><b>QPixmap</b></a> ( const QString &amp; fileName, const char * format, int conversion_flags ) </div>
<li><div class="fn"><a href="#0aa453"><b>QPixmap</b></a> ( const char * xpm[] ) </div>
<li><div class="fn"><a href="#d59e6d"><b>QPixmap</b></a> ( const QByteArray &amp; data ) </div>
<li><div class="fn"><a href="#5e960a"><b>QPixmap</b></a> ( const QPixmap &amp; ) </div>
<li><div class="fn"><a href="#5eee10"><b>~QPixmap</b></a> () </div>
<li><div class="fn">QPixmap&amp; <a href="#54e957"><b>operator=</b></a> ( const QPixmap &amp; ) </div>
<li><div class="fn">QPixmap&amp; <a href="#bb68bd"><b>operator=</b></a> ( const QImage &amp; ) </div>
<li><div class="fn">bool <a href="#29cbd3"><b>isNull</b></a> () const</div>
<li><div class="fn">int <a href="#443c1f"><b>width</b></a> () const</div>
<li><div class="fn">int <a href="#1d578d"><b>height</b></a> () const</div>
<li><div class="fn">QSize <a href="#45aaf7"><b>size</b></a> () const</div>
<li><div class="fn">QRect <a href="#1c205e"><b>rect</b></a> () const</div>
<li><div class="fn">int <a href="#64b028"><b>depth</b></a> () const</div>
<li><div class="fn">void <a href="#fe206f"><b>fill</b></a> ( const QColor &amp; fillColor = Qt::white ) </div>
<li><div class="fn">void <a href="#163dd1"><b>fill</b></a> ( const QWidget *, int xofs, int yofs ) </div>
<li><div class="fn">void <a href="#e584bd"><b>fill</b></a> ( const QWidget *, const QPoint &amp; ofs ) </div>
<li><div class="fn">void <a href="#9792fe"><b>resize</b></a> ( int width, int height ) </div>
<li><div class="fn">void <a href="#f28939"><b>resize</b></a> ( const QSize &amp; ) </div>
<li><div class="fn">const QBitmap* <a href="#463d64"><b>mask</b></a> () const</div>
<li><div class="fn">void <a href="#ffddf9"><b>setMask</b></a> ( const QBitmap &amp; ) </div>
<li><div class="fn">bool <a href="#3a2cb4"><b>selfMask</b></a> () const</div>
<li><div class="fn">QBitmap <a href="#e3124a"><b>createHeuristicMask</b></a> ( bool clipTight = TRUE ) const</div>
<li><div class="fn">QPixmap <a href="#3b77c0"><b>xForm</b></a> ( const QWMatrix &amp; ) const</div>
<li><div class="fn">QImage <a href="#95e53d"><b>convertToImage</b></a> () const</div>
<li><div class="fn">bool <a href="#b1cac8"><b>convertFromImage</b></a> ( const QImage &amp;, ColorMode mode=Auto ) </div>
<li><div class="fn">bool <a href="#f34554"><b>convertFromImage</b></a> ( const QImage &amp;, int conversion_flags ) </div>
<li><div class="fn">bool <a href="#88e576"><b>load</b></a> ( const QString &amp; fileName, const char * format=0, ColorMode mode=Auto ) </div>
<li><div class="fn">bool <a href="#775e08"><b>load</b></a> ( const QString &amp; fileName, const char * format, int conversion_flags ) </div>
<li><div class="fn">bool <a href="#038a6c"><b>loadFromData</b></a> ( const uchar * buf, uint len, const char * format=0, ColorMode mode=Auto ) </div>
<li><div class="fn">bool <a href="#f3526a"><b>loadFromData</b></a> ( const uchar * buf, uint len, const char * format, int conversion_flags ) </div>
<li><div class="fn">bool <a href="#eb8c25"><b>loadFromData</b></a> ( const QByteArray &amp; data, const char * format=0, int conversion_flags=0 ) </div>
<li><div class="fn">bool <a href="#07cdad"><b>save</b></a> ( const QString &amp; fileName, const char * format ) const</div>
<li><div class="fn">bool <a href="#e3d450"><b>save</b></a> ( const QString &amp; fileName, const char * format, int quality ) const</div>
<li><div class="fn">int <a href="#10c1cd"><b>serialNumber</b></a> () const</div>
<li><div class="fn">Optimization <a href="#9419b4"><b>optimization</b></a> () const</div>
<li><div class="fn">void <a href="#9b0dee"><b>setOptimization</b></a> ( Optimization ) </div>
<li><div class="fn">virtual void <a href="#52d113"><b>detach</b></a> () </div>
<li><div class="fn">bool <a href="#a065e7"><b>isQBitmap</b></a> () const</div>
</ul>
<h2>Static Public Members</h2>
<ul>
<li><div class="fn">int <a href="#c81546"><b>defaultDepth</b></a> () </div>
<li><div class="fn">QPixmap <a href="#b687cd"><b>grabWindow</b></a> ( WId, int x=0, int y=0, int w=-1, int h=-1 ) </div>
<li><div class="fn">QPixmap <a href="#f9166c"><b>grabWidget</b></a> ( QWidget * widget, int x=0, int y=0, int w=-1, int h=-1 ) </div>
<li><div class="fn">QWMatrix <a href="#b37e43"><b>trueMatrix</b></a> ( const QWMatrix &amp;, int w, int h ) </div>
<li><div class="fn">const char* <a href="#b1fdd9"><b>imageFormat</b></a> ( const QString &amp; fileName ) </div>
<li><div class="fn">Optimization <a href="#35082b"><b>defaultOptimization</b></a> () </div>
<li><div class="fn">void <a href="#0a2479"><b>setDefaultOptimization</b></a> ( Optimization ) </div>
</ul>
<h2>Protected Members</h2>
<ul>
<li><div class="fn"><a href="#19a8f6"><b>QPixmap</b></a> ( int w, int h, const uchar * data, bool isXbitmap ) </div>
<li><div class="fn">virtual int <a href="#470eab"><b>metric</b></a> ( int ) const</div>
</ul>
<h2>Related Functions</h2>
(Note that these are not member functions.)
<ul>
<li>QDataStream &amp; <a href="qpixmap.html#12eff7"><b>operator&gt;&gt;</b></a> (QDataStream &amp; s, QPixmap &amp; pixmap)
<li>QDataStream &amp; <a href="qpixmap.html#f20fe5"><b>operator&lt;&lt;</b></a> (QDataStream &amp; s, const QPixmap &amp; pixmap)
</ul>
<hr><h2><a name="details"></a>Detailed Description</h2>
The QPixmap class is an off-screen pixel-based paint device.
<p>
It is one of the two classes Qt provides for dealing with images,
the other being <a href="qimage.html">QImage</a>.  QPixmap is designed and optimized for
drawing; QImage is designed and optimized for I/O and for direct
pixel access/manipulation.  There are (slow) functions to convert
between QImage and QPixmap; <a href="#95e53d">convertToImage</a>() and <a href="#f34554">convertFromImage</a>().
<p>One common use of the QPixmap class is to enable smooth updating of
widgets.  Whenever something complex needs to be drawn, you can use
a pixmap to obtain flicker-free drawing, like this:
<p><ol plain>
<li> Create a pixmap with the same size as the widget.
<li> Fill the pixmap with the widget background color.
<li> Paint the pixmap.
<li> <a href="qpaintdevice.html#058006">bitBlt</a>() the pixmap contents onto the widget.
</ol>
<p>Pixel data in a pixmap is internal and managed by the underlying
window system.  Pixels can only be accessed through <a href="qpainter.html">QPainter</a>
functions, through bitBlt(), and by converting the QPixmap to a
QImage.
<p>You can display a QPixmap on the screen easily using
e.g. <a href="qlabel.html#f3f301">QLabel::setPixmap</a>(), and all the <a href="qbutton.html">QButton</a> subclasses support
pixmap use.
<p>The QPixmap class uses lazy copying, so it is practical to pass pass
QPixmap objects as arguments.
<p>Note about Windows 95 and 98: On Windows 9x, the system crashes if
you create more than approximately 1000 pixmaps, independent of the
size of the pixmaps or installed RAM.  Windows NT does not have this
limitation.
<p>Qt tries to work around the resource limitation.  If you set the
pixmap optimization to <code>QPixmap::MemoryOptim</code> and the width of your
pixmap is less than or equal to 128 pixels, Qt stores the pixmap in
a way which is very memory-efficient when there are many pixmaps.
<p>If your application uses dozens or hundreds of pixmaps, e.g. on tool
bar buttons, in popup menus, and you plan to run it on Windows 95 or
Windows 98, then we recommend using code like this:
<p><pre>    <a href="#0a2479">QPixmap::setDefaultOptimization</a>( QPixmap::MemoryOptim );
    while ( ... ) {
      // load tool bar pixmaps etc.
      <a href="qpixmap.html">QPixmap</a> *pixmap = new <a href="qpixmap.html">QPixmap</a>(fileName);
    }
    <a href="#0a2479">QPixmap::setDefaultOptimization</a>( QPixmap::NormalOptim );
</pre>
<p>See also  <a href="qbitmap.html">QBitmap</a>, <a href="qimage.html">QImage</a>, <a href="qimageio.html">QImageIO</a> and <a href="shclass.html">Shared Classes</a>
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#QPixmap">qtimage/qtimage.cpp</a>
 <a href="grapher-grapher-cpp.html#QPixmap">grapher/grapher.cpp</a>
 <a href="xform-xform-cpp.html#QPixmap">xform/xform.cpp</a>
 <a href="menu-menu-cpp.html#QPixmap">menu/menu.cpp</a>
 <a href="qmag-qmag-cpp.html#QPixmap">qmag/qmag.cpp</a>
 <a href="desktop-desktop-cpp.html#QPixmap">desktop/desktop.cpp</a>
 <a href="scrollview-scrollview-cpp.html#QPixmap">scrollview/scrollview.cpp</a>
 <a href="movies-main-cpp.html#QPixmap">movies/main.cpp</a>
 <a href="picture-picture-cpp.html#QPixmap">picture/picture.cpp</a>

<hr><h2>Member Type Documentation</h2>
<h3 class="fn"><a name="ColorMode">QPixmap::ColorMode</a></h3>
This enum type defines the color modes that exist for converting
<a href="qimage.html">QImage</a> objects to QPixmap.  The current values are: <ul>
<li> <code>Auto</code> - select <code>Color</code> or <code>Mono</code> on a case-by-case basis.
<li> <code>Color</code> - always create colored pixmaps.
<li> <code>Mono</code> - always create bitmaps.
</ul>
<h3 class="fn"><a name="Optimization">QPixmap::Optimization</a></h3>
QPixmap has the choice of optimizing for speed or memory in a few
places, and the best choice varies from pixmap to pixmap, but can
generally be derived heuristically.  This enum type defines a number
of optimization modes you can set for any pixmap, to tweak the
speed/memory tradeoffs:
<p><ul>
<li> <code>DefaultOptim</code> - whatever <a href="#35082b">QPixmap::defaultOptimization</a>()
returns.  A pixmap with this optimization mode set always has the
default optimization type, even if the default is changed with
<a href="#0a2479">setDefaultOptimization</a>().
<li> <code>NoOptim</code> - no optimization (currently the same as <code>MemoryOptim).</code>
<li> <code>MemoryOptim</code> - optimize for minimal memory use.
<li> <code>NormalOptim</code> - optimize for typical usage.  Often uses more
memory than <code>MemoryOptim,</code> and often faster.
<li> <code>BestOptim</code> - optimize for pixmaps that are drawn very often
and where performance is critical.  Generally uses more memory than
<code>NormalOptim</code> and may provide a little better speed.
<p></ul>
<p>We recommend sticking with <code>DefaultOptim</code>
<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="1668f6"></a>QPixmap::QPixmap ()</h3>
<p>Constructs a null pixmap.
<p>See also  <a href="#29cbd3">isNull</a>().
<h3 class="fn"><a name="d59e6d"></a>QPixmap::QPixmap ( const <a href="qbytearray.html">QByteArray</a> &amp; img_data )</h3>
<p>Constructs a pixmaps by loading from <em>img_data.</em>
The data can be in any image format supported by Qt.
<p>See also  <a href="#f3526a">loadFromData</a>().
<h3 class="fn"><a name="393682"></a>QPixmap::QPixmap ( const <a href="qstring.html">QString</a> &amp; fileName, const char * format, int conversion_flags )</h3>
<p>Constructs a pixmap from the file <em>fileName.</em> If the file does not
exist, or is of an unknown format, the pixmap becomes a null pixmap.
<p>The parameters are passed on to <a href="#775e08">load</a>().
<p>See also  <a href="#29cbd3">isNull</a>(), <a href="#775e08">load</a>(), <a href="#f3526a">loadFromData</a>(), <a href="#07cdad">save</a>() and <a href="#b1fdd9">imageFormat</a>().
<h3 class="fn"><a name="8141b4"></a>QPixmap::QPixmap ( const <a href="qstring.html">QString</a> &amp; fileName, const char * format=0, <a href="qpixmap.html#ColorMode">ColorMode</a> mode=Auto )</h3>
<p>Constructs a pixmap from the file <em>fileName.</em> If the file does not
exist, or is of an unknown format, the pixmap becomes a null pixmap.
<p>The parameters are passed on to <a href="#775e08">load</a>().
<p>See also  <a href="#29cbd3">isNull</a>(), <a href="#775e08">load</a>(), <a href="#f3526a">loadFromData</a>(), <a href="#07cdad">save</a>() and <a href="#b1fdd9">imageFormat</a>().
<h3 class="fn"><a name="5e960a"></a>QPixmap::QPixmap ( const QPixmap &amp; pixmap )</h3>
<p>Constructs a pixmap which is a copy of <em>pixmap.</em>
<h3 class="fn"><a name="0aa453"></a>QPixmap::QPixmap ( const char * xpm[] )</h3>
<p>Constructs a pixmap from <em>xpm,</em> which must be a valid XPM image.
<p>Error are silently ignored.
<p>Note that it's possible to squeeze the XPM variable a little bit by
using an unusual declaration:
<p><pre>    static const char * const start_xpm[]={
        "16 15 8 1",
        "a c #cec6bd",
    ....
</pre>
<p>The extra <code>const</code> makes the entire definition read-only, which is
slightly more efficient e.g. when the code is in a shared library,
and ROMable when the application is to be stored in ROM.
<p>In order to use that sort of declaration, you must cast the variable
back to <nobr><code>const char **</code></nobr> when you create the
QPixmap.
<h3 class="fn"><a name="19a8f6"></a>QPixmap::QPixmap ( int w, int h, const uchar * bits, bool isXbitmap ) <code>[protected]</code></h3>
<p>Constructs a monochrome pixmap which is initialized with the data in <em>bits.</em>
This constructor is protected and used by the <a href="qbitmap.html">QBitmap</a> class.
<h3 class="fn"><a name="d62968"></a>QPixmap::QPixmap ( int w, int h, int depth = -1, <a href="qpixmap.html#Optimization">Optimization</a> optimization = DefaultOptim )</h3>
<p>Constructs a pixmap with <em>w</em> width, <em>h</em> height and of <em>depth</em> bits per
pixels.
<p>The contents of the pixmap is uninitialized.
<p>The <em>depth</em> can be either 1 (monochrome) or the depth of the
current video mode.  If <em>depth</em> is negative, then the hardware
depth of the current video mode will be used.
<p>If either <em>width</em> or <em>height</em> is zero, a null pixmap is constructed.
<p>See also  <a href="#29cbd3">isNull</a>().
<h3 class="fn"><a name="08aba0"></a>QPixmap::QPixmap ( const <a href="qsize.html">QSize</a> &amp; size, int depth = -1, <a href="qpixmap.html#Optimization">Optimization</a> optimization = DefaultOptim )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn"><a name="5eee10"></a>QPixmap::~QPixmap ()</h3>
<p>Destructs the pixmap.
<h3 class="fn">bool <a name="f34554"></a>QPixmap::convertFromImage ( const <a href="qimage.html">QImage</a> &amp; img, int conversion_flags )</h3>
<p>Converts an image and sets this pixmap. Returns TRUE if successful.
<p>The <em>conversion_flags</em> argument is a bitwise-OR from the following choices.
The options marked <em>(default)</em> are the choice if no other choice from the
list is included (they are zero):
<p><dl>
<dt>Color/Mono preference (ignored for <a href="qbitmap.html">QBitmap</a>)
<dd>
<ul>
<li> <code>AutoColor</code> (default) - If the <em>image</em> has <a href="qimage.html#9d6e2d">depth</a> 1 and contains only
black and white pixels, then the pixmap becomes monochrome.
<li> <code>ColorOnly</code> - The pixmap is dithered/converted to the
<a href="#c81546">native display depth</a>.
<li> <code>MonoOnly</code> - The pixmap becomes monochrome.  If necessary,
it is dithered using the chosen dithering algorithm.
</ul>
<dt>Dithering mode preference, for RGB channels
<dd>
<ul>
<li> <code>DiffuseDither</code> (default) - a high quality dither
<li> <code>OrderedDither</code> - a faster more ordered dither
<li> <code>ThresholdDither</code> - no dithering, closest color is used
</ul>
<dt>Dithering mode preference, for alpha channel
<dd>
<ul>
<li> <code>DiffuseAlphaDither</code> - a high quality dither
<li> <code>OrderedAlphaDither</code> - a faster more ordered dither
<li> <code>ThresholdAlphaDither</code> (default) - no dithering
</ul>
<dt>Color matching versus dithering preference
<dd>
<ul>
<li> <code>PreferDither</code> - always dither 32-bit images when
the image
is being converted to 8-bits.
This is the default when converting to a pixmap.
<li> <code>AvoidDither</code> - only dither 32-bit images if
the image
has more than 256 colors and it
is being converted to 8-bits.
This is the default when an image is converted
for the purpose of saving to a file.
</ul>
</dl>
<p>Passing 0 for <em>conversion_flags</em> gives all the default options.
<p>Note that even though a QPixmap with depth 1 behaves much like a
QBitmap, <a href="#a065e7">isQBitmap</a>() returns FALSE.
<p>If a pixmap with depth 1 is painted with color0 and color1 and
converted to an image, the pixels painted with color0 will produce
pixel index 0 in the image and those painted with color1 will produce
pixel index 1.
<p>See also  <a href="#95e53d">convertToImage</a>(), <a href="#a065e7">isQBitmap</a>(), <a href="qimage.html#7dbce4">QImage::convertDepth</a>(), <a href="#c81546">defaultDepth</a>() and <a href="qimage.html#f19991">QImage::hasAlphaBuffer</a>().
<p>Bugs and limitations:
<ul>
<li>Does not support 2 or 4 bit display hardware.
</ul>
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#convertFromImage">qtimage/qtimage.cpp</a>
<h3 class="fn">bool <a name="b1cac8"></a>QPixmap::convertFromImage ( const <a href="qimage.html">QImage</a> &amp; image, <a href="qpixmap.html#ColorMode">ColorMode</a> mode=Auto )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn"><a href="qimage.html">QImage</a> <a name="95e53d"></a>QPixmap::convertToImage () const</h3>
<p>Converts the pixmap to an image. Returns a null image if the operation
failed.
<p>If the pixmap has 1 bit depth, the returned image will also be 1
bits deep.  If the pixmap has 2-8 bit depth, the returned image
has 8 bit depth.  If the pixmap has greater than 8 bit depth, the
returned image has 32 bit depth.
<p>See also  <a href="#f34554">convertFromImage</a>().
<p>Bugs and limitations:
<ul>
<li>Does not support 2 or 4 bit display hardware.
<li>Alpha masks on monochrome images are ignored.
</ul>
<p>Examples:
 <a href="qmag-qmag-cpp.html#convertToImage">qmag/qmag.cpp</a>
<h3 class="fn"><a href="qbitmap.html">QBitmap</a> <a name="e3124a"></a>QPixmap::createHeuristicMask ( bool clipTight = TRUE ) const</h3>
<p>Creates and returns a heuristic mask for this pixmap. It works by
selecting a color from one of the corners, then chipping away pixels of
that color, starting at all the edges.
<p>The mask may not be perfect but should be reasonable, so you can do
things like:
<pre>    pm-&gt;setMask( pm-&gt;createHeuristicMask() );
</pre>
<p>This function is slow because it involves transformation to a <a href="qimage.html">QImage</a>,
non-trivial computations and a transformation back to <a href="qbitmap.html">QBitmap</a>.
<p>See also  <a href="qimage.html#7c5bce">QImage::createHeuristicMask</a>().
<h3 class="fn">int <a name="c81546"></a>QPixmap::defaultDepth () <code>[static]</code></h3>
<p>Returns the default pixmap depth, i.e. the depth a pixmap gets
if -1 is specified.
<p>See also  <a href="#64b028">depth</a>().
<h3 class="fn">QPixmap::Optimization <a name="35082b"></a>QPixmap::defaultOptimization() <code>[static]</code></h3>
<p>Returns the default pixmap optimization setting.
<p>See also  <a href="#0a2479">setDefaultOptimization</a>(), <a href="#9b0dee">setOptimization</a>() and <a href="#9419b4">optimization</a>().
<h3 class="fn">int <a name="64b028"></a>QPixmap::depth () const</h3>
<p>Returns the depth of the image.
<p>The pixmap depth is also called bits per pixel (bpp) or bit planes
of a pixmap.  A null pixmap has depth 0.
<p>See also  <a href="#c81546">defaultDepth</a>(), <a href="#29cbd3">isNull</a>() and <a href="qimage.html#7dbce4">QImage::convertDepth</a>().
<h3 class="fn">void <a name="52d113"></a>QPixmap::detach () <code>[virtual]</code></h3>
<p>Special-purpose function that detaches the pixmap from shared pixmap data.
<p>A pixmap is automatically detached by Qt whenever its contents is about
to change.  This is done in all QPixmap member functions that modify the
pixmap (<a href="#e584bd">fill</a>(), <a href="#9792fe">resize</a>(), <a href="#f34554">convertFromImage</a>(), <a href="#775e08">load</a>() etc.), in <a href="qpaintdevice.html#058006">bitBlt</a>()
for the destination pixmap and in <a href="qpainter.html#59f1bb">QPainter::begin</a>() on a pixmap.
<p>It is possible to modify a pixmap without letting Qt know.
You can first obtain the <a href="qpaintdevice.html#7767e5">system-dependent handle</a>
and then call system-specific functions (for instance BitBlt under Windows)
that modifies the pixmap contents.  In this case, you can call detach()
to cut the pixmap loose from other pixmaps that share data with this one.
<p>detach() returns immediately if there is just a single reference or if
the pixmap has not been initialized yet.
<h3 class="fn">void <a name="fe206f"></a>QPixmap::fill ( const <a href="qcolor.html">QColor</a> &amp; fillColor = Qt::white )</h3>
<p>Fills the pixmap with the color <em>fillColor.</em>
<h3 class="fn">void <a name="e584bd"></a>QPixmap::fill ( const <a href="qwidget.html">QWidget</a> * widget, const <a href="qpoint.html">QPoint</a> &amp; ofs )</h3>
<p>Fills the pixmap with the widget's background color or pixmap.
If the background is empty, nothing is done.
<p>The <em>ofs</em> point is an offset in the widget.
<p>The point <em>ofs</em> is a point in the widget's coordinate system. The
pixmap's top left pixel will be mapped to the point <em>ofs</em> in the
widget. This is significant if the widget has a background pixmap,
otherwise the pixmap will simply be filled with the background color of
the widget.
<p>Example:
<pre>  void CuteWidget::paintEvent( <a href="qpaintevent.html">QPaintEvent</a> *e )
  {
    <a href="qrect.html">QRect</a> ur = e-&gt;<a href="qpaintevent.html#6177d5">rect</a>();               // rectangle to update

    <a href="qpixmap.html">QPixmap</a>  pix( ur.<a href="qrect.html#517d48">size</a>() );          // Pixmap for double-buffering

    pix.<a href="#e584bd">fill</a>( this, ur.<a href="qrect.html#4ff486">topLeft</a>() );     // fill with widget background

    <a href="qpainter.html">QPainter</a> p( &amp;pix );
    p.<a href="qpainter.html#ba64b6">translate</a>( -ur.<a href="qrect.html#3a3d38">x</a>(), -ur.<a href="qrect.html#65e614">y</a>() );    // use widget coordinate system
                                        // when drawing on pixmap
    //    ... draw on pixmap ...

    p.<a href="qpainter.html#c7f9ac">end</a>();

    <a href="qpaintdevice.html#058006">bitBlt</a>( this, ur.<a href="qrect.html#4ff486">topLeft</a>(), &amp;pix );
  }
</pre>
<p>Examples:
 <a href="grapher-grapher-cpp.html#fill">grapher/grapher.cpp</a>
 <a href="xform-xform-cpp.html#fill">xform/xform.cpp</a>
 <a href="desktop-desktop-cpp.html#fill">desktop/desktop.cpp</a>
<h3 class="fn">void <a name="163dd1"></a>QPixmap::fill ( const <a href="qwidget.html">QWidget</a> * widget, int xofs, int yofs )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">QPixmap <a name="f9166c"></a>QPixmap::grabWidget ( <a href="qwidget.html">QWidget</a> * widget, int x=0, int y=0, int w=-1, int h=-1 ) <code>[static]</code></h3>
<p>Creates a pixmap and paints <em>widget</em> in it.
<p>If <em>widget</em> has children, they are painted too, appropriately located.
<p>If you specify <em>x, y, w</em> or <em>h,</em> only the rectangle you
specify is painted.  The defaults are 0, 0 (top-left corner) and
-1,-1 (which means the entire widget).
<p>(If <em>w</em> is negative, the function copies everything to the right
border of the window.  If <em>h</em> is negative, the function copies
everything to the bottom of the window.)
<p>If <em>widget</em> is 0, or if the rectangle defined by <em>x, y,</em> the
modified <em>w</em> and the modified <em>h</em> does not overlap the <em>widget-><a href="#1c205e">rect</a>(),</em> this function returns a null QPixmap.
<p>This function actually asks <em>widget</em> to paint itself (and its
children to paint themselves).  <a href="#b687cd">QPixmap::grabWindow</a>() grabs pixels
off the screen, which is a bit faster and picks up <em>exactly</em> what's
on-screen.  This function works by calling paintEvent() with painter
redirection turned on, which gets the result of paintEvent(),
without e.g. overlying windows.
<p>If there is overlap, it returns a pixmap of the size you want,
containing a rendering of <em>widget.</em>  If the rectangle you ask for
is a superset of <em>widget,</em> the area outside <em>widget</em> are covered
with the widget's background.
<p>See also  <a href="#b687cd">grabWindow</a>(), <a href="qpainter.html#fc6836">QPainter::redirect</a>() and <a href="qwidget.html#ef2069">QWidget::paintEvent</a>().
<h3 class="fn">QPixmap <a name="b687cd"></a>QPixmap::grabWindow ( WId window, int x=0, int y=0, int w=-1, int h=-1 ) <code>[static]</code></h3>
<p>Grabs the contents of a window and makes a pixmap out of it.
Returns the pixmap.
<p>The arguments <em>(x,y)</em> specify the offset in the window, while
<em>(w,h)</em> specify the width and height of the area to be copied.
<p>If <em>w</em> is negative, the function copies everything to the right
border of the window.  If <em>h</em> is negative, the function copies
everything to the bottom of the window.
<p>Note that grabWindows() grabs pixels from the screen, not from the
window.  This means that If there is another window partially or
entirely over the one you grab, you get pixels from the overlying
window too.
<p>Note also that the mouse cursor is generally not grabbed.
<p>The reason we use a window identifier and not a <a href="qwidget.html">QWidget</a> is to enable
grabbing of windows that are not part of the application, window
system frames, and so on.<p><b>Warning:</b> Grabbing an area outside the screen is not safe in general.
This depends on the underlying window system.
<p>See also  <a href="#f9166c">grabWidget</a>().
<h3 class="fn">int <a name="1d578d"></a>QPixmap::height () const</h3>
<p>Returns the height of the pixmap.
<p>See also  <a href="#443c1f">width</a>(), <a href="#45aaf7">size</a>() and <a href="#1c205e">rect</a>().
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#height">qtimage/qtimage.cpp</a>
 <a href="xform-xform-cpp.html#height">xform/xform.cpp</a>
 <a href="desktop-desktop-cpp.html#height">desktop/desktop.cpp</a>
 <a href="scrollview-scrollview-cpp.html#height">scrollview/scrollview.cpp</a>
 <a href="movies-main-cpp.html#height">movies/main.cpp</a>
<h3 class="fn">const char* <a name="b1fdd9"></a>QPixmap::imageFormat ( const <a href="qstring.html">QString</a> &amp; fileName ) <code>[static]</code></h3>
<p>Returns a string that specifies the image format of the file <em>fileName,</em>
or null if the file cannot be read or if the format cannot be recognized.
<p>The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats.
<p>See also  <a href="#775e08">load</a>() and <a href="#07cdad">save</a>().
<h3 class="fn">bool <a name="29cbd3"></a>QPixmap::isNull () const</h3>
<p>Returns TRUE if it is a null pixmap.
<p>A null pixmap has zero width, zero height and no contents.
You cannot draw in a null pixmap or <a href="qpaintdevice.html#058006">bitBlt</a>() anything to it.
<p>Resizing an existing pixmap to (0,0) makes a pixmap into a null
pixmap.
<p>See also  <a href="#9792fe">resize</a>().
<p>Examples:
 <a href="qmag-qmag-cpp.html#isNull">qmag/qmag.cpp</a>
 <a href="scrollview-scrollview-cpp.html#isNull">scrollview/scrollview.cpp</a>
<h3 class="fn">bool <a name="a065e7"></a>QPixmap::isQBitmap () const</h3>
<p>Returns TRUE if this is a <a href="qbitmap.html">QBitmap</a>, otherwise FALSE.
<h3 class="fn">bool <a name="775e08"></a>QPixmap::load ( const <a href="qstring.html">QString</a> &amp; fileName, const char * format, int conversion_flags )</h3>
<p>Loads a pixmap from the file <em>fileName.</em>
Returns TRUE if successful, or FALSE if the pixmap could not be loaded.
<p>If <em>format</em> is specified, the loader attempts to read the pixmap using the
specified format. If <em>format</em> is not specified (default),
the loader reads a few bytes from the header to guess the file format.
<p>See the <a href="#f34554">convertFromImage</a>() documentation for a description
of the <em>conversion_flags</em> argument.
<p>The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats and
explains how to add extra formats.
<p>See also  <a href="#f3526a">loadFromData</a>(), <a href="#07cdad">save</a>(), <a href="#b1fdd9">imageFormat</a>(), <a href="qimage.html#081350">QImage::load</a>() and <a href="qimageio.html">QImageIO</a>.
<p>Examples:
 <a href="xform-xform-cpp.html#load">xform/xform.cpp</a>
 <a href="scrollview-scrollview-cpp.html#load">scrollview/scrollview.cpp</a>
 <a href="picture-picture-cpp.html#load">picture/picture.cpp</a>
<h3 class="fn">bool <a name="88e576"></a>QPixmap::load ( const <a href="qstring.html">QString</a> &amp; fileName, const char * format=0, <a href="qpixmap.html#ColorMode">ColorMode</a> mode=Auto )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">bool <a name="f3526a"></a>QPixmap::loadFromData ( const uchar * buf, uint len, const char * format, int conversion_flags )</h3>
<p>Loads a pixmap from the binary data in <em>buf</em> (<em>len</em> bytes).
Returns TRUE if successful, or FALSE if the pixmap could not be loaded.
<p>If <em>format</em> is specified, the loader attempts to read the pixmap using the
specified format. If <em>format</em> is not specified (default),
the loader reads a few bytes from the header to guess the file format.
<p>See the <a href="#f34554">convertFromImage</a>() documentation for a description
of the <em>conversion_flags</em> argument.
<p>The <a href="qimageio.html">QImageIO</a> documentation lists the supported image formats and
explains how to add extra formats.
<p>See also  <a href="#775e08">load</a>(), <a href="#07cdad">save</a>(), <a href="#b1fdd9">imageFormat</a>(), <a href="qimage.html#7f7d57">QImage::loadFromData</a>() and <a href="qimageio.html">QImageIO</a>.
<h3 class="fn">bool <a name="eb8c25"></a>QPixmap::loadFromData ( const <a href="qbytearray.html">QByteArray</a> &amp; buf, const char * format=0, int conversion_flags=0 )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">bool <a name="038a6c"></a>QPixmap::loadFromData ( const uchar * buf, uint len, const char * format=0, <a href="qpixmap.html#ColorMode">ColorMode</a> mode=Auto )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">const <a href="qbitmap.html">QBitmap</a> * <a name="463d64"></a>QPixmap::mask () const</h3>
<p>Returns the mask bitmap, or null if no mask has been set.
<p>See also  <a href="#ffddf9">setMask</a>() and <a href="qbitmap.html">QBitmap</a>.
<h3 class="fn">int <a name="470eab"></a>QPixmap::metric ( int m ) const <code>[virtual protected]</code></h3>
<p>Internal implementation of the virtual <a href="qpaintdevice.html#af35dc">QPaintDevice::metric</a>() function.
<p>Use the <a href="qpaintdevicemetrics.html">QPaintDeviceMetrics</a> class instead.
<p>Reimplemented from <a href="qpaintdevice.html#af35dc">QPaintDevice.</a>
<h3 class="fn">QPixmap &amp; <a name="bb68bd"></a>QPixmap::operator= ( const <a href="qimage.html">QImage</a> &amp; image )</h3>
<p>Converts the image <em>image</em> to a pixmap that is assigned to this pixmap.
Returns a reference to the pixmap.
<p>See also  <a href="#f34554">convertFromImage</a>().
<h3 class="fn">QPixmap &amp; <a name="54e957"></a>QPixmap::operator= ( const QPixmap &amp; pixmap )</h3>
<p>Assigns the pixmap <em>pixmap</em> to this pixmap and returns a reference to
this pixmap.
<h3 class="fn">QPixmap::Optimization <a name="9419b4"></a>QPixmap::optimization() const</h3>
<p>Returns the optimization setting for this pixmap.
<p>The default optimization setting is <code>QPixmap::NormalOptim.</code> You may
change this settings in two ways:
<ul>
<li> Call <a href="#0a2479">setDefaultOptimization</a>() to set the default optimization
for all new pixmaps.
<li> Call <a href="#9b0dee">setOptimization</a>() to set a the optimization for individual
pixmaps.
</ul>
<p>See also  <a href="#9b0dee">setOptimization</a>(), <a href="#0a2479">setDefaultOptimization</a>() and <a href="#35082b">defaultOptimization</a>().
<h3 class="fn"><a href="qrect.html">QRect</a> <a name="1c205e"></a>QPixmap::rect () const</h3>
<p>Returns the enclosing rectangle (0,0,<a href="#443c1f">width</a>(),<a href="#1d578d">height</a>()) of the pixmap.
<p>See also  <a href="#443c1f">width</a>(), <a href="#1d578d">height</a>() and <a href="#45aaf7">size</a>().
<p>Examples:
 <a href="xform-xform-cpp.html#rect">xform/xform.cpp</a>
<h3 class="fn">void <a name="9792fe"></a>QPixmap::resize ( int w, int h )</h3>
<p>Resizes the pixmap to <em>w</em> width and <em>h</em> height.  If either <em>w</em>
or <em>h</em> is less than 1, the pixmap becomes a null pixmap.
<p>If both <em>w</em> and <em>h</em> are greater than 0, a valid pixmap is created.
New pixels will be uninitialized (random) if the pixmap is expanded.
<p>Examples:
 <a href="grapher-grapher-cpp.html#resize">grapher/grapher.cpp</a>
 <a href="desktop-desktop-cpp.html#resize">desktop/desktop.cpp</a>
<h3 class="fn">void <a name="f28939"></a>QPixmap::resize ( const <a href="qsize.html">QSize</a> &amp; size )</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">bool <a name="07cdad"></a>QPixmap::save ( const <a href="qstring.html">QString</a> &amp; fileName, const char * format ) const</h3>
<p>Saves the pixmap to the file <em>fileName,</em> using the image file format
<em>format.</em>  Returns TRUE if successful, or FALSE if the pixmap could not
be saved.
<p>See also  <a href="#775e08">load</a>(), <a href="#f3526a">loadFromData</a>(), <a href="#b1fdd9">imageFormat</a>(), <a href="qimage.html#86943f">QImage::save</a>() and <a href="qimageio.html">QImageIO</a>.
<p>Examples:
 <a href="qmag-qmag-cpp.html#save">qmag/qmag.cpp</a>
<h3 class="fn">bool <a name="e3d450"></a>QPixmap::save ( const <a href="qstring.html">QString</a> &amp; fileName, const char * format, int quality ) const</h3>
<p>Saves the pixmap to the file <em>fileName,</em> using the image file format
<em>format</em> and a quality factor <em>quality. quality</em> must be in the
range [0,100] or -1.  Specify 0 to obtain small compressed files, 100
for large uncompressed files and -1 to use the default settings.
Returns TRUE if successful, or FALSE if the pixmap could not be saved.
<p>See also  <a href="#775e08">load</a>(), <a href="#f3526a">loadFromData</a>(), <a href="#b1fdd9">imageFormat</a>(), <a href="qimage.html#86943f">QImage::save</a>() and <a href="qimageio.html">QImageIO</a>.
<h3 class="fn">bool <a name="3a2cb4"></a>QPixmap::selfMask () const</h3>
<p>Returns TRUE if the pixmap's mask is identical to the pixmap itself.
<p>See also  <a href="#463d64">mask</a>().
<h3 class="fn">int <a name="10c1cd"></a>QPixmap::serialNumber () const</h3>
<p>Returns a number that uniquely identifies the contents of this QPixmap object.
This means that multiple QPixmaps objects can have the same serial number
as long as they refer to the same contents.
The serial number is for example very useful for caching.
<p>See also  <a href="qpixmapcache.html">QPixmapCache</a>.
<h3 class="fn">void <a name="0a2479"></a>QPixmap::setDefaultOptimization ( <a href="qpixmap.html#Optimization">Optimization</a> optimization ) <code>[static]</code></h3>
<p>Sets the default pixmap optimization.
<p>All <em>new</em> pixmaps that are created will use this default optimization.
You may also set optimization for individual pixmaps using the
<a href="#9b0dee">setOptimization</a>() function.
<p>The initial default optimization setting is <code>QPixmap::Normal.</code>
<p>See also  <a href="#35082b">defaultOptimization</a>(), <a href="#9b0dee">setOptimization</a>() and <a href="#9419b4">optimization</a>().
<h3 class="fn">void <a name="ffddf9"></a>QPixmap::setMask ( const <a href="qbitmap.html">QBitmap</a> &amp; newmask )</h3>
<p>Sets a mask bitmap.
<p>The <em>mask</em> bitmap defines the clip mask for this pixmap. Every pixel in
<em>mask</em> corresponds to a pixel in this pixmap. Pixel value 1 means opaque
and pixel value 0 means transparent. The mask must have the same size as
this pixmap.
<p>Setting a <a href="#29cbd3">null</a> mask resets the mask,
<p>See also  <a href="#463d64">mask</a>(), <a href="#e3124a">createHeuristicMask</a>() and <a href="qbitmap.html">QBitmap</a>.
<h3 class="fn">void <a name="9b0dee"></a>QPixmap::setOptimization ( <a href="qpixmap.html#Optimization">Optimization</a> optimization )</h3>
<p>Sets pixmap drawing optimization for this pixmap.
<p>The optimization setting affects pixmap operations, in particular
drawing of transparent pixmaps (<a href="qpaintdevice.html#058006">bitBlt</a>() a pixmap with a mask set) and
pixmap transformations (the <a href="#3b77c0">xForm</a>() function).
<p>Pixmap optimization involves keeping intermediate results in a cache
buffer and use the data in the cache to speed up bitBlt() and xForm().
The cost is more memory consumption, up to twice as much as an
unoptimized pixmap.
<p>Use the <a href="#0a2479">setDefaultOptimization</a>() to change the default optimization
for all new pixmaps.
<p>See also  <a href="#9419b4">optimization</a>(), <a href="#0a2479">setDefaultOptimization</a>() and <a href="#35082b">defaultOptimization</a>().
<p>Examples:
 <a href="desktop-desktop-cpp.html#setOptimization">desktop/desktop.cpp</a>
<h3 class="fn"><a href="qsize.html">QSize</a> <a name="45aaf7"></a>QPixmap::size () const</h3>
<p>Returns the size of the pixmap.
<p>See also  <a href="#443c1f">width</a>(), <a href="#1d578d">height</a>() and <a href="#1c205e">rect</a>().
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#size">qtimage/qtimage.cpp</a>
 <a href="movies-main-cpp.html#size">movies/main.cpp</a>
<h3 class="fn"><a href="qwmatrix.html">QWMatrix</a> <a name="b37e43"></a>QPixmap::trueMatrix ( const <a href="qwmatrix.html">QWMatrix</a> &amp; matrix, int w, int h ) <code>[static]</code></h3>
<p>Returns the actual matrix used for transforming a pixmap with <em>w</em>
width and <em>h</em> height.
<p>When transforming a pixmap with <a href="#3b77c0">xForm</a>(), the transformation matrix
is internally adjusted to compensate for unwanted translation,
i.e. xForm() returns the smallest pixmap containing all transformed
points of the original pixmap.
<p>This function returns the modified matrix, which maps points
correctly from the original pixmap into the new pixmap.
<p>See also  <a href="#3b77c0">xForm</a>() and <a href="qwmatrix.html">QWMatrix</a>.
<h3 class="fn">int <a name="443c1f"></a>QPixmap::width () const</h3>
<p>Returns the width of the pixmap.
<p>See also  <a href="#1d578d">height</a>(), <a href="#45aaf7">size</a>() and <a href="#1c205e">rect</a>().
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#width">qtimage/qtimage.cpp</a>
 <a href="xform-xform-cpp.html#width">xform/xform.cpp</a>
 <a href="desktop-desktop-cpp.html#width">desktop/desktop.cpp</a>
 <a href="scrollview-scrollview-cpp.html#width">scrollview/scrollview.cpp</a>
 <a href="movies-main-cpp.html#width">movies/main.cpp</a>
<h3 class="fn">QPixmap <a name="3b77c0"></a>QPixmap::xForm ( const <a href="qwmatrix.html">QWMatrix</a> &amp; matrix ) const</h3>
<p>Returns a copy of the pixmap that is transformed using <em>matrix.</em>
<p>Qt uses this function to implement rotated text on window systems
that do not support such complex features.
<p>Example of how to manually draw a rotated text at (100,200) in a widget:
<pre>    char    *str = "Trolls R Qt";       // text to be drawn
    <a href="qfont.html">QFont</a>    f( "Charter", 24 );        // use Charter 24pt font
    <a href="qpixmap.html">QPixmap</a>  pm( 8, 8 );
    <a href="qpainter.html">QPainter</a> p;
    <a href="qrect.html">QRect</a>    r;                         // text bounding rectangle
    <a href="qpoint.html">QPoint</a>   bl;                        // text baseline position

    p.<a href="qpainter.html#59f1bb">begin</a>( &amp;pm );                     // first get the bounding
    p.<a href="qpainter.html#e4d6b7">setFont</a>( f );                     //   text rectangle
    r = p.<a href="qpainter.html#f572a5">fontMetrics</a>().boundingRect(str);
    bl = -r.<a href="qrect.html#4ff486">topLeft</a>();                  // get baseline position
    p.<a href="qpainter.html#c7f9ac">end</a>();

    pm.<a href="#9792fe">resize</a>( r.<a href="qrect.html#517d48">size</a>() );              // resize to fit the text
    pm.<a href="#e584bd">fill</a>( white );                   // fills pm with white
    p.<a href="qpainter.html#59f1bb">begin</a>( &amp;pm );                     // begin painting pm
    p.<a href="qpainter.html#e4d6b7">setFont</a>( f );                     // set the font
    p.<a href="qpainter.html#0a6aff">setPen</a>( blue );                   // set blue text color
    p.<a href="qpainter.html#8a59ed">drawText</a>( bl, str );              // draw the text
    p.<a href="qpainter.html#c7f9ac">end</a>();                            // painting done

    <a href="qwmatrix.html">QWMatrix</a> m;                         // transformation matrix
    m.<a href="qwmatrix.html#84df75">rotate</a>( -33.4 );                  // rotate coordinate system
    <a href="qpixmap.html">QPixmap</a> rp = pm.<a href="#3b77c0">xForm</a>( m );         // rp is rotated pixmap

    <a href="qwmatrix.html">QWMatrix</a> t = QPixmap::trueMatrix( m, pm.<a href="#443c1f">width</a>(), pm.<a href="#1d578d">height</a>() );
    int x, y;
    t.<a href="qwmatrix.html#38577f">map</a>( bl.<a href="qpoint.html#1ed201">x</a>(),bl.<a href="qpoint.html#90c362">y</a>(), &amp;x,&amp;y );      // get pm's baseline pos in rp

    <a href="qpaintdevice.html#058006">bitBlt</a>( myWidget, 100-x, 200-y,     // blt rp into a widget
            &amp;rp, 0, 0, -1, -1 );
</pre>
<p>This example outlines how Qt implements rotated text under X11.
The font calculation is the most tedious part. The rotation itself is
only 3 lines of code.
<p>If you want to draw rotated text, you do not have to implement all the
code above. The code below does exactly the same thing as the example
above, except that it uses a <a href="qpainter.html">QPainter</a>.
<p><pre>    char    *str = "Trolls R Qt";       // text to be drawn
    <a href="qfont.html">QFont</a>    f( "Charter", 24 );        // use Charter 24pt font
    <a href="qpainter.html">QPainter</a> p;

    p.<a href="qpainter.html#59f1bb">begin</a>( myWidget );
    p.<a href="qpainter.html#ba64b6">translate</a>( 100, 200 );            // translates coord system
    p.<a href="qpainter.html#4bd0fb">rotate</a>( -33.4 );                  // rotates it counterclockwise
    p.<a href="qpainter.html#e4d6b7">setFont</a>( f );
    p.<a href="qpainter.html#8a59ed">drawText</a>( 0, 0, str );
    p.<a href="qpainter.html#c7f9ac">end</a>();
</pre>
<p>See also  <a href="#b37e43">trueMatrix</a>(), <a href="qwmatrix.html">QWMatrix</a> and <a href="qpainter.html#f4a354">QPainter::setWorldMatrix</a>().
<p>Bugs and limitations:
<ul>
<li>2 and 4 bits pixmaps are not supported.
</ul>
<p>Examples:
 <a href="qtimage-qtimage-cpp.html#xForm">qtimage/qtimage.cpp</a>
 <a href="xform-xform-cpp.html#xForm">xform/xform.cpp</a>
 <a href="qmag-qmag-cpp.html#xForm">qmag/qmag.cpp</a>
 <a href="desktop-desktop-cpp.html#xForm">desktop/desktop.cpp</a>
 <a href="movies-main-cpp.html#xForm">movies/main.cpp</a>
<hr><h2>Related Functions</h2>
<h3><a href="qdatastream.html">QDataStream</a> &amp; <a name="12eff7"></a>operator&gt;&gt; (<a href="qdatastream.html">QDataStream</a> &amp; s, QPixmap &amp; pixmap)</h3>
<p>Reads a pixmap from the stream.
<p>See also  <a href="qpixmap.html#775e08">QPixmap::load</a>() and <a href="datastreamformat.html">Format of the QDataStream operators</a>

<h3><a href="qdatastream.html">QDataStream</a> &amp; <a name="f20fe5"></a>operator&lt;&lt; (<a href="qdatastream.html">QDataStream</a> &amp; s, const QPixmap &amp; pixmap)</h3>
<p>Writes a pixmap to the stream as a PNG image.
<p>See also  <a href="qpixmap.html#07cdad">QPixmap::save</a>() and <a href="datastreamformat.html">Format of the QDataStream operators</a>

<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses
<a href="http://www.trolltech.com">www.trolltech.com</a>):<br>
<form method=post action="http://www.trolltech.com/search.cgi">
<input type=hidden name="version" value="2.3.1"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-2000
<a href="http://www.trolltech.com">Trolltech</a>, all rights reserved.<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 2000 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 2.3.1</div>
</table></div></address></body></html>
