<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Qt Toolkit - QTextCodec Class</title><style type="text/css"><!--
h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm; }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }body { background: white; color: black; }
--></style>
</head><body bgcolor="#ffffff">

<table width="100%">
<tr><td><a href="index.html">
<img width="100" height="100" src="qtlogo.png"
alt="Home" border="0"><img width="100"
height="100" src="face.png" alt="Home" border="0">
</a><td valign=top><div align=right><img src="dochead.png" width="472" height="27"><br>
<a href="classes.html"><b>Classes</b></a>
- <a href="annotated.html">Annotated</a>
- <a href="hierarchy.html">Tree</a>
- <a href="functions.html">Functions</a>
- <a href="index.html">Home</a>
- <a href="topicals.html"><b>Structure</b></a>
</div>
</table>

<h1 align=center>QTextCodec Class Reference</h1><br clear="all">
<p>
Provides conversion between text encodings.
<a href="#details">More...</a>
<p>
<code>#include &lt;<a href="qtextcodec-h.html">qtextcodec.h</a>&gt;</code>
<p>Inherited by <a href="qeucjpcodec.html">QEucJpCodec</a>, <a href="qeuckrcodec.html">QEucKrCodec</a>, <a href="qgbkcodec.html">QGbkCodec</a>, <a href="qjiscodec.html">QJisCodec</a>, <a href="qsjiscodec.html">QSjisCodec</a> and <a href="qtsciicodec.html">QTsciiCodec</a>.
<p><a href="qtextcodec-members.html">List of all member functions.</a>
<h2>Public Members</h2>
<ul>
<li><div class="fn">virtual <a href="#cfbcd3"><b>~QTextCodec</b></a> () </div>
<li><div class="fn">virtual const char* <a href="#fcf223"><b>name</b></a> () const</div>
<li><div class="fn">virtual int <a href="#b0aafb"><b>mibEnum</b></a> () const</div>
<li><div class="fn">virtual QTextDecoder* <a href="#bfe11b"><b>makeDecoder</b></a> () const</div>
<li><div class="fn">virtual QTextEncoder* <a href="#c400c7"><b>makeEncoder</b></a> () const</div>
<li><div class="fn">virtual QString <a href="#235cd6"><b>toUnicode</b></a> ( const char * chars, int len ) const</div>
<li><div class="fn">virtual QCString <a href="#7e416f"><b>fromUnicode</b></a> ( const QString &amp; uc, int &amp; lenInOut ) const</div>
<li><div class="fn">QCString <a href="#1b9a7f"><b>fromUnicode</b></a> ( const QString &amp; uc ) const</div>
<li><div class="fn">QString <a href="#a63608"><b>toUnicode</b></a> ( const QByteArray &amp;, int len ) const</div>
<li><div class="fn">QString <a href="#594de7"><b>toUnicode</b></a> ( const QByteArray &amp; ) const</div>
<li><div class="fn">QString <a href="#eb8c0e"><b>toUnicode</b></a> ( const char * chars ) const</div>
<li><div class="fn">virtual bool <a href="#288c5c"><b>canEncode</b></a> ( QChar ) const</div>
<li><div class="fn">virtual bool <a href="#7d2a14"><b>canEncode</b></a> ( const QString &amp; ) const</div>
<li><div class="fn">virtual int <a href="#461187"><b>heuristicContentMatch</b></a> ( const char * chars, int len ) const</div>
<li><div class="fn">virtual int <a href="#144365"><b>heuristicNameMatch</b></a> ( const char * hint ) const</div>
</ul>
<h2>Static Public Members</h2>
<ul>
<li><div class="fn">QTextCodec* <a href="#1b8155"><b>loadCharmap</b></a> ( QIODevice * ) </div>
<li><div class="fn">QTextCodec* <a href="#bc4c6e"><b>loadCharmapFile</b></a> ( QString filename ) </div>
<li><div class="fn">QTextCodec* <a href="#1d8f7b"><b>codecForMib</b></a> ( int mib ) </div>
<li><div class="fn">QTextCodec* <a href="#aee6fe"><b>codecForName</b></a> ( const char * hint, int accuracy=0 ) </div>
<li><div class="fn">QTextCodec* <a href="#beb462"><b>codecForContent</b></a> ( const char * chars, int len ) </div>
<li><div class="fn">QTextCodec* <a href="#f72313"><b>codecForIndex</b></a> ( int i ) </div>
<li><div class="fn">QTextCodec* <a href="#20e3df"><b>codecForLocale</b></a> () </div>
<li><div class="fn">void <a href="#9ee91f"><b>deleteAllCodecs</b></a> () </div>
<li><div class="fn">const char* <a href="#75defa"><b>locale</b></a> () </div>
</ul>
<h2>Protected Members</h2>
<ul>
<li><div class="fn"><a href="#f9b2db"><b>QTextCodec</b></a> () </div>
</ul>
<h2>Static Protected Members</h2>
<ul>
<li><div class="fn">int <a href="#d7db3c"><b>simpleHeuristicNameMatch</b></a> ( const char * name, const char * hint ) </div>
</ul>
<hr><h2><a name="details"></a>Detailed Description</h2>
Provides conversion between text encodings.
<p>
By making objects of subclasses of QTextCodec, support for
new text encodings can be added to Qt.
<p>The abstract virtual functions describe the encoder to the
system and the coder is used as required in the different
text file formats supported <a href="qtextstream.html">QTextStream</a> and, under X11 for the
locale-specific character input and output (under Windows NT
codecs are not needed for GUI I/O since the system works
with Unicode already, and Windows 95/98 has built-in convertors
for the 8-bit local encoding).
<p>More recently created QTextCodec objects take precedence
over earlier ones.
<p>To add support for another 8-bit encoding to Qt, make a subclass
or QTextCodec and implement at least the following methods:
<dl>
<dt><code>const</code> char* <a href="#fcf223">name</a>() const
<dd>Return the official name for the encoding.
<dt><code>int</code> <a href="#b0aafb">mibEnum</a>() const
<dd>Return the MIB enum for the encoding if it is listed in the
<a href=ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets>
IANA character-sets encoding file</a>.
</dl>
If the encoding is multi-byte then it will have "state"; that is,
the interpretation of some bytes will be dependent on some preceding
bytes.  For such an encoding, you will need to implement
<dl>
<dt> <code><a href="qtextdecoder.html">QTextDecoder</a>*</code> <a href="#bfe11b">makeDecoder</a>() const
<dd>Return a QTextDecoder that remembers incomplete multibyte
sequence prefixes or other required state.
</dl>
If the encoding does <em>not</em> require state, you should implement:
<dl>
<dt> <code><a href="qstring.html">QString</a></code> <a href="#235cd6">toUnicode</a>(const char* chars, int len) const
<dd>Converts <em>len</em> characters from <em>chars</em> to Unicode.
</dl>
The base QTextCodec class has default implementations of the above
two functions, <i>but they are mutually recursive</i>, so you must
re-implement at least one of them, or both for improved efficiency.
<p>For conversion from Unicode to 8-bit encodings, it is rarely necessary
to maintain state.  However, two functions similar to the two above
are used for encoding:
<dl>
<dt> <code><a href="qtextencoder.html">QTextEncoder</a>*</code> <a href="#c400c7">makeEncoder</a>() const
<dd>Return a QTextDecoder.
<dt> <code><a href="qcstring.html">QCString</a></code> <a href="#7e416f">fromUnicode</a>(const QString& uc, int& lenInOut ) const;
<dd>Converts <em>lenInOut</em> characters (of type <a href="qchar.html">QChar</a>) from the start
of the string <em>uc,</em> returning a QCString result, and also returning
the <a href="qcstring.html#acf534">length</a>
of the result in lenInOut.
</dl>
Again, these are mutually recursive so only one needs to be implemented,
or both if better efficiency is possible.
<p>Finally, you must implement:
<dl>
<dt> <code>int</code> <a href="#461187">heuristicContentMatch</a>(const char* chars, int len) const
<dd>Gives a value indicating how likely it is that <em>len</em> characters
from <em>chars</em> are in the encoding.
</dl>
A good model for this function is the
QWindowsLocalCodec::heuristicContentMatch function found in the Qt sources.
<p>A QTextCodec subclass might have improved performance if you also
re-implement:
<dl>
<dt> <code>bool</code> <a href="#288c5c">canEncode</a>( QChar ) const
<dd>Test if a Unicode character can be encoded.
<dt> <code>bool</code> canEncode( const QString& ) const
<dd>Test if a string of Unicode characters can be encoded.
<dt> <code>int</code> <a href="#144365">heuristicNameMatch</a>(const char* hint) const
<dd>Test if a possibly non-standard name is referring to the codec.
</dl>

<hr><h2>Member Function Documentation</h2>
<h3 class="fn"><a name="f9b2db"></a>QTextCodec::QTextCodec () <code>[protected]</code></h3>
<p>Constructs a QTextCodec, making it of highest precedence.
The QTextCodec should always be constructed on the heap
(with new), and once constructed it becomes the responsibility
of Qt to delete it (which is done at <a href="qapplication.html">QApplication</a> destruction).
<h3 class="fn"><a name="cfbcd3"></a>QTextCodec::~QTextCodec () <code>[virtual]</code></h3>
<p>Destructs the QTextCodec.  Note that you should not delete
codecs yourself - once created they become the responsibility
of Qt to delete.
<h3 class="fn">bool <a name="288c5c"></a>QTextCodec::canEncode ( <a href="qchar.html">QChar</a> ch ) const <code>[virtual]</code></h3>
<p>Returns TRUE if the unicode character <em>ch</em> can be fully encoded
with this codec.  The default implementation tests if the result of
<a href="#235cd6">toUnicode</a>(<a href="#7e416f">fromUnicode</a>(ch)) is the original <em>ch.</em> Subclasses may be
able to improve the efficiency.
<h3 class="fn">bool <a name="7d2a14"></a>QTextCodec::canEncode ( const <a href="qstring.html">QString</a> &amp; s ) const <code>[virtual]</code></h3>
<p>Returns TRUE if the unicode string <em>s</em> can be fully encoded
with this codec.  The default implementation tests if the result of
<a href="#235cd6">toUnicode</a>(<a href="#7e416f">fromUnicode</a>(s)) is the original <em>s.</em> Subclasses may be
able to improve the efficiency.
<h3 class="fn">QTextCodec* <a name="beb462"></a>QTextCodec::codecForContent ( const char * chars, int len ) <code>[static]</code></h3>
<p>Searches all installed QTextCodec objects, returning the one
which most recognizes the given content.  May return 0.
<p>Note that this is often a poor choice, since character
encodings often use most of the available character sequences,
and so only by linguistic analysis could a true match be made.
<p>See also  <a href="#461187">heuristicContentMatch</a>().
<h3 class="fn">QTextCodec* <a name="f72313"></a>QTextCodec::codecForIndex ( int i ) <code>[static]</code></h3>
<p>Returns the QTextCodec <em>i</em> places from the more recently
inserted, or NULL if there is no such QTextCodec.  Thus,
codecForIndex(0) returns the most recently created QTextCodec.
<h3 class="fn">QTextCodec* <a name="20e3df"></a>QTextCodec::codecForLocale () <code>[static]</code></h3>
<p>Returns a pointer to the codec most suitable for this locale.
<h3 class="fn">QTextCodec* <a name="1d8f7b"></a>QTextCodec::codecForMib ( int mib ) <code>[static]</code></h3>
<p>Returns the QTextCodec which matches the
<a href="#b0aafb">MIBenum</a> <em>mib.</em>
<h3 class="fn">QTextCodec* <a name="aee6fe"></a>QTextCodec::codecForName ( const char * hint, int accuracy=0 ) <code>[static]</code></h3>
<p>Searches all installed QTextCodec objects, returning the one
which best matches given name.  Returns NULL if no codec has
a match closeness above <em>accuracy.</em>
<p>See also  <a href="#144365">heuristicNameMatch</a>().
<h3 class="fn">void <a name="9ee91f"></a>QTextCodec::deleteAllCodecs () <code>[static]</code></h3>
<p>Deletes all the created codecs.<p><b>Warning:</b> Do not call this function.
<p><a href="qapplication.html">QApplication</a> calls this just before exiting, to delete any
QTextCodec objects that may be lying around.  Since various other
classes hold pointers to QTextCodec objects, it is not safe to call
this function earlier.
<p>If you are using the utility classes (like <a href="qstring.html">QString</a>) but not using
QApplication, calling this function at the very end of your
application can be helpful to chasing down memory leaks, as
QTextCodec objects will not show up.
<h3 class="fn"><a href="qcstring.html">QCString</a> <a name="7e416f"></a>QTextCodec::fromUnicode ( const <a href="qstring.html">QString</a> &amp; uc, int &amp; lenInOut ) const <code>[virtual]</code></h3>
<p>Subclasses of QTextCodec must reimplement either this function or
<a href="#c400c7">makeEncoder</a>().  It converts the first <em>lenInOut</em> characters of <em>uc</em> from Unicode to the encoding of the subclass.  If <em>lenInOut</em>
is negative or too large, the length of <em>uc</em> is used instead.
<p>The value returned is the property of the caller, which is
responsible for deleting it with "delete []".  The length of the
resulting Unicode character sequence is returned in <em>lenInOut.</em>
<p>The default implementation makes an encoder with makeEncoder() and
converts the input with that.  Note that the default makeEncoder()
implementation makes an encoder that simply calls
this function, hence subclasses <em>must</em> reimplement one function or
the other to avoid infinite recursion.
<p>Reimplemented in <a href="qeucjpcodec.html#82fc6c">QEucJpCodec</a>, <a href="qgbkcodec.html#c75341">QGbkCodec</a>, <a href="qeuckrcodec.html#8d1f7e">QEucKrCodec</a>, <a href="qsjiscodec.html#64aa26">QSjisCodec</a>, <a href="qjiscodec.html#f426f8">QJisCodec</a> and <a href="qtsciicodec.html#9d2355">QTsciiCodec</a>.
<h3 class="fn"><a href="qcstring.html">QCString</a> <a name="1b9a7f"></a>QTextCodec::fromUnicode ( const <a href="qstring.html">QString</a> &amp; uc ) const</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn">int <a name="461187"></a>QTextCodec::heuristicContentMatch ( const char * chars, int len ) const <code>[virtual]</code></h3>
<p>Subclasses of QTextCodec must reimplement this function.  It examines
the first <em>len</em> bytes of <em>chars</em> and returns a value indicating how
likely it is that the string is a prefix of text encoded in the
encoding of the subclass.  Any negative return value indicates that the text
is detectably not in the encoding (eg. it contains undefined characters).
A return value of 0 indicates that the text should be decoded with this
codec rather than as ASCII, but there
is no particular evidence.  The value should range up to <em>len.</em>  Thus,
most decoders will return -1, 0, or -<em>len.</em>
<p>The characters are not null terminated.
<p>See also  <a href="#beb462">codecForContent</a>().
<p>Reimplemented in <a href="qeucjpcodec.html#6f6f7e">QEucJpCodec</a>, <a href="qjiscodec.html#398490">QJisCodec</a>, <a href="qgbkcodec.html#33905d">QGbkCodec</a>, <a href="qeuckrcodec.html#6c64e2">QEucKrCodec</a>, <a href="qsjiscodec.html#939e34">QSjisCodec</a> and <a href="qtsciicodec.html#368e50">QTsciiCodec</a>.
<h3 class="fn">int <a name="144365"></a>QTextCodec::heuristicNameMatch ( const char * hint ) const <code>[virtual]</code></h3>
<p>Returns a value indicating how likely this decoder is
for decoding some format that has the given name.
<p>A good match returns a positive number around
the length of the string.  A bad match is negative.
<p>The default implementation calls <a href="#d7db3c">simpleHeuristicNameMatch</a>()
with the name of the codec.
<p>Reimplemented in <a href="qgbkcodec.html#002b13">QGbkCodec</a>, <a href="qjiscodec.html#999d2b">QJisCodec</a>, <a href="qeuckrcodec.html#7821d3">QEucKrCodec</a>, <a href="qsjiscodec.html#8e56e1">QSjisCodec</a>, <a href="qeucjpcodec.html#a66400">QEucJpCodec</a> and <a href="qtsciicodec.html#87cfd3">QTsciiCodec</a>.
<h3 class="fn">QTextCodec* <a name="1b8155"></a>QTextCodec::loadCharmap ( <a href="qiodevice.html">QIODevice</a> * iod ) <code>[static]</code></h3>
<p>Reads a POSIX2 charmap definition from <em>iod.</em>
The parser recognizes the following lines:
<pre>
   &lt;code_set_name&gt; <i>name</i>
   &lt;escape_char&gt; <i>character</i>
   % alias <i>alias</i>
   CHARMAP
   &lt;<i>token</i>&gt; /x<i>hexbyte</i> &lt;U<i>unicode</i>&gt; ...
   &lt;<i>token</i>&gt; /d<i>decbyte</i> &lt;U<i>unicode</i>&gt; ...
   &lt;<i>token</i>&gt; /<i>octbyte</i> &lt;U<i>unicode</i>&gt; ...
   &lt;<i>token</i>&gt; /<i>any</i>/<i>any</i>... &lt;U<i>unicode</i>&gt; ...
   END CHARMAP
</pre>
<p>The resulting QTextCodec is returned (and also added to the
global list of codecs).  The <a href="#fcf223">name</a>() of the result is taken
from the code_set_name.
<p>Note that a codec constructed in this way uses much more memory
and is slower than a hand-written QTextCodec subclass, since
tables in code are in memory shared by all applications simultaneously
using Qt.
<p>See also  <a href="#bc4c6e">loadCharmapFile</a>().
<h3 class="fn">QTextCodec* <a name="bc4c6e"></a>QTextCodec::loadCharmapFile ( <a href="qstring.html">QString</a> filename ) <code>[static]</code></h3>
<p>A convenience function for <a href="#1b8155">loadCharmap</a>().
<h3 class="fn">const char* <a name="75defa"></a>QTextCodec::locale () <code>[static]</code></h3>
<p>Returns a string representing the current language.
<h3 class="fn"><a href="qtextdecoder.html">QTextDecoder</a>* <a name="bfe11b"></a>QTextCodec::makeDecoder () const <code>[virtual]</code></h3>
<p>Creates a <a href="qtextdecoder.html">QTextDecoder</a> which stores enough state to decode chunks
of char* data to create chunks of Unicode data.  The default implementation
creates a stateless decoder, which is sufficient for only the simplest
encodings where each byte corresponds to exactly one Unicode character.
<p>The caller is responsible for deleting the returned object.
<p>Reimplemented in <a href="qeuckrcodec.html#42c97f">QEucKrCodec</a>, <a href="qeucjpcodec.html#29a830">QEucJpCodec</a>, <a href="qjiscodec.html#db0000">QJisCodec</a>, <a href="qsjiscodec.html#da0c52">QSjisCodec</a> and <a href="qgbkcodec.html#d19813">QGbkCodec</a>.
<h3 class="fn"><a href="qtextencoder.html">QTextEncoder</a>* <a name="c400c7"></a>QTextCodec::makeEncoder () const <code>[virtual]</code></h3>
<p>Creates a <a href="qtextencoder.html">QTextEncoder</a> which stores enough state to encode chunks
of Unicode data as char* data.  The default implementation
creates a stateless encoder, which is sufficient for only the simplest
encodings where each Unicode character corresponds to exactly one char.
<p>The caller is responsible for deleting the returned object.
<h3 class="fn">int <a name="b0aafb"></a>QTextCodec::mibEnum () const <code>[virtual]</code></h3>
<p>Subclasses of QTextCodec must reimplement this function.  It returns the
MIBenum (see
<a href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">
the IANA character-sets encoding file</a> for more information).
It is important that each QTextCodec subclass return the correct unique
value for this function.
<h3 class="fn">const char* <a name="fcf223"></a>QTextCodec::name () const <code>[virtual]</code></h3>
<p>Subclasses of QTextCodec must reimplement this function.  It returns
the name of the encoding supported by the subclass.  When choosing
a name for an encoding, consider these points:
<ul>
<li>On X11, <a href="#144365">heuristicNameMatch</a>( const char * hint )
is used to test if a the QTextCodec
can convert between Unicode and the encoding of a font
with encoding <em>hint,</em> such as "iso8859-1" for Latin-1 fonts,
"koi8-r" for Russian KOI8 fonts.
The default algorithm of heuristicNameMatch() uses name().
<li>Some applications may use this function to present
encodings to the end user.
</ul>
<p>Reimplemented in <a href="qjiscodec.html#56ac5a">QJisCodec</a>, <a href="qeucjpcodec.html#d246a4">QEucJpCodec</a>, <a href="qeuckrcodec.html#83df76">QEucKrCodec</a>, <a href="qgbkcodec.html#eadeab">QGbkCodec</a>, <a href="qtsciicodec.html#40d1a1">QTsciiCodec</a> and <a href="qsjiscodec.html#bfa51e">QSjisCodec</a>.
<h3 class="fn">int <a name="d7db3c"></a>QTextCodec::simpleHeuristicNameMatch ( const char * name, const char * hint ) <code>[static protected]</code></h3>
<p>A simple utility function for <a href="#144365">heuristicNameMatch</a>() - it
does some very minor character-skipping
so that almost-exact matches score high.
<h3 class="fn"><a href="qstring.html">QString</a> <a name="235cd6"></a>QTextCodec::toUnicode ( const char * chars, int len ) const <code>[virtual]</code></h3>
<p>Subclasses of QTextCodec must reimplement this function or
<a href="#bfe11b">makeDecoder</a>().  It converts the first <em>len</em> characters of <em>chars</em>
to Unicode.
<p>The default implementation makes a decoder with makeDecoder() and
converts the input with that.  Note that the default makeDecoder()
implementation makes a decoder that simply calls
this function, hence subclasses <em>must</em> reimplement one function or
the other to avoid infinite recursion.
<p>Reimplemented in <a href="qeucjpcodec.html#5f278a">QEucJpCodec</a>, <a href="qeuckrcodec.html#36bd2c">QEucKrCodec</a>, <a href="qjiscodec.html#1133ea">QJisCodec</a>, <a href="qsjiscodec.html#0e3d92">QSjisCodec</a>, <a href="qgbkcodec.html#3c284a">QGbkCodec</a> and <a href="qtsciicodec.html#1219dc">QTsciiCodec</a>.
<h3 class="fn"><a href="qstring.html">QString</a> <a name="594de7"></a>QTextCodec::toUnicode ( const <a href="qbytearray.html">QByteArray</a> &amp; a ) const</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn"><a href="qstring.html">QString</a> <a name="a63608"></a>QTextCodec::toUnicode ( const <a href="qbytearray.html">QByteArray</a> &amp; a, int len ) const</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<h3 class="fn"><a href="qstring.html">QString</a> <a name="eb8c0e"></a>QTextCodec::toUnicode ( const char * chars ) const</h3>
<p>This is an overloaded member function, provided for convenience.  It differs from the above function only in what argument(s) it accepts.
<hr><p>
Search the documentation, FAQ, qt-interest archive and more (uses
<a href="http://www.trolltech.com">www.trolltech.com</a>):<br>
<form method=post action="http://www.trolltech.com/search.cgi">
<input type=hidden name="version" value="2.3.1"><nobr>
<input size="50" name="search"><input type=submit value="Search">
</nobr></form><hr><p>
This file is part of the <a href="index.html">Qt toolkit</a>,
copyright &copy; 1995-2000
<a href="http://www.trolltech.com">Trolltech</a>, all rights reserved.<p><address><hr><div align="center">
<table width="100%" cellspacing="0" border="0"><tr>
<td>Copyright © 2000 Trolltech<td><a href="http://www.trolltech.com/trademarks.html">Trademarks</a>
<td align="right"><div align="right">Qt version 2.3.1</div>
</table></div></address></body></html>
